{"posts":[{"title":"ThreadLocal 为什么要这么实现？","text":"多线程环境下，编程需要考虑并发安全问题。常规思路是通过锁来实现，ThreadLocal 则提供了另一种线程安全的实现方式：避免共享。通过 ThreadLocal 定义的变量，不同的线程都会拥有这个变量的副本，没有共享，也就没有并发问题了。 具体的使用方式可以看 JDK 源码中提供的示例，下面这个类中，定义了一个静态私有的 ThreadLocal 变量，为每个线程生成唯一标识。当一个线程首次调用 get 方法时，会调用初始化方法 initialValue，为当前线程分配唯一的 thread id，并且在之后同一个线程再次调用 get 方法时，直接返回这个值。 这里区分两个概念，一个是 ThreadLocal 变量，一个是 ThreadLocal 变量“包裹”的对象（在这个例子中是一个 Integer 对象）。准确来说，ThreadLocal 变量是唯一的，不同线程持有的是 ThreadLocal “包裹”的对象的副本。 1234567891011121314151617public class ThreadId { // Atomic integer containing the next thread ID to be assigned private static final AtomicInteger nextId = new AtomicInteger(0); // Thread local variable containing each thread's ID private static final ThreadLocal&lt;Integer&gt; threadId = new ThreadLocal&lt;Integer&gt;() { @Override protected Integer initialValue() { return nextId.getAndIncrement(); } }; // Returns the current thread's unique ID, assigning it if necessary public static int get() { return threadId.get(); }} 实现原理介绍 ThreadLocal 是如何实现的前，可以尝试自己来实现这样的效果。很容易想到，可以在 ThreadLocal 内创建一个 Map，key 是线程，value 是线程持有的变量。示意图如下所示。 ThreadLocal 持有 Map 但实际上 Java 中的实现，这个 Map 是保存在 Thread 对象中的，key 是 ThreadLocal，value 是线程持有的变量，示意图如下所示，核心代码实现也很简单。 Thread 持有ThreadLocal Map 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class ThreadLocal&lt;T&gt; { public T get() { Thread t = Thread.currentThread(); // 从当前线程中获取 ThreadLocalMap ThreadLocalMap map = getMap(t); if (map != null) { // ThreadLocal 作为 key，从 map 中获取 value ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; } } // map 还没初始化，这里执行初始化逻辑 return setInitialValue(); } public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } private T setInitialValue() { T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value; } void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); }}public class Thread { ThreadLocal.ThreadLocalMap threadLocals = null; ThreadLocalMap getMap(Thread t) { return t.threadLocals; }} Java 中的实现和自定义实现，哪种方式更好呢，显然 Java 的实现更好一点，这里我总结了一下几点优势，这也是为什么 Java 要这样实现 ThreadLocal 的原因。 ThreadLocal 仅仅作为工具类，不持有任何线程相关的数据，而是将这些数据保存在 Thread 对象中，设计上更加容易理解 自定义实现中使用需要使用并发安全的 Map 来存放数据，存在锁竞争，而 Java 实现中每个线程对各自数据的读写都是独立的，没有并发问题，性能更好 自定义实现中，ThreadLocal 对象持有线程引用，通常 ThreadLocal 对象的生命周期要更长，如果线程没有主动删除对应的 key-value，会导致 Thread 对象无法被回收，导致内存泄漏 内存泄漏前面我们提到 Java 这样实现 ThreadLocal 是有助于避免内存泄漏的，因为 Thread 对象持有线程本地数据，当线程销毁后，它所持有的对象副本也会被 GC 回收。 但前面我们忽略了一点，因为程序中往往是通过线程池来使用线程的，所以线程的生命周期可能也非常长。所以 Thread 对象中持有线程本地数据时，也可能导致内存泄漏。 所以 Java 实现中还做了一项优化，就是 ThreadLocalMap 中的 Entry 实现为弱引用，通过弱引用指向 key，也就是 ThreadLocal 变量，这样当程序中声明的 ThreadLocal 变量声明周期结束后，因为这里是弱引用，所以可以被顺利回收。 123456789101112static class ThreadLocalMap { static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) { super(k); value = v; } }} 那是否 Java 实现的 ThreadLocal 一定不会发生内存泄漏呢？不是的，因为 ThreadLocalMap 中 Entry 的 value 并不是弱引用，如果程序中没有及时将 value 从 map 中移除，即使 value 的生命周期结束了，也无法被回收，这里还是会发生内存泄漏。为了避免发生这种情况，我们需要在代码中手动释放 Entry 对 value 的强引用，使用示例如下： 123456789101112ExecutorService es;ThreadLocal tl;es.execute(()-&gt;{ //ThreadLocal增加变量 tl.set(obj); try { // 省略业务逻辑代码 }finally { //手动清理ThreadLocal tl.remove(); }}); 应用场景了解了 ThreadLocal 的实现原理，不知道你会不会有这样的疑问，在什么情况下才需要用到 ThreadLocal 呢？如果只是为了避免共享，我直接将要用的变量声明为局部变量不可以吗？ 答案是不可以，考虑这样两种场景： 这个对象创建过程非常耗时、耗资源，如果每次使用时都重新创建可能导致性能问题 这个对象只能在某个方法中获取，但需要在很多方法中使用，如果声明为局部变量，则需要在整个链路中所有方法中进行传递，如果这个变量和业务逻辑没有紧密联系，会非常影响代码可读性、可维护性 所以，通常我们会把一些线程间不需要共享，但在同一线程，多个方法调用中都可能使用到，同时和业务逻辑关系不紧密的数据，放在 ThreadLocal 中。 看几个具体的例子： 程序中经常会用 traceId 把一次用户请求在系统中调用的路径串联起来，traceId 信息非常适合通过 ThreadLocal 保存 用户登陆系统后，针对用户的每次请求，可以从 Session 或者Token 中获取用户信息，保存到 ThreadLocal 中，在需要使用的时候可以很方便的获取到 从数据库连接池获取链接后，Connection 对象放到 ThreadLocal 中，Spring 的事务管理，底层实现就利用的这样的机制 使用 ThreadLocal 时，还需要特别注意以下几种情况： 配合线程池使用时，要知道线程池中的线程生命周期会非常长，会在不同的请求间复用，所以一定要主动 remove 使用完毕的 ThreadLocal 变量，防止内存泄漏，也防止对下次请求造成影响 异步调用中，ThreadLocal 是无法传递的，要避免在这样的场景中依赖 ThreadLocal 变量，或者手动实现 ThreadLocal 的跨线程传递 InheritableThreadLocalJava 中还提供了一个 InheritableThreadLocal 类来支持父子线程之间线程本地存储变量的继承，InheritableThreadLocal 是 ThreadLocal 的子类，之所以能实现继承特性，其实是在初始化线程时，有一步操作，专门将父线程的成员变量 inheritableThreadLocals 指向的 ThreadLocalMap 中的变量拷贝到了子线程中。 12345678910public class Thread { private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) { ... // 将父线程的 inheritableThreadLocals 指向的 ThreadLocalMap 中的变量拷贝到当前线程 if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); ... }} 总结并发编程中，ThreadLocal 通过避免共享的方式实现了线程安全。Java 中 ThreadLocal 的实现，是将线程本地数据通过 ThreadLocalMap 放在的 Thread 对象中，ThreadLocal 变量做 key，ThreadLocal “包裹”的对象副本做 value。并且 ThreadLocalMap 的 Entry 实现为弱引用，指向ThreadLocal 变量，防止内存泄漏。但是要想完全避免内存泄漏，使用时要记得及时释放对 value 的强引用。最后，要记得全链路 traceId，登陆用户信息，Spring 事务中的数据路链接等典型的应用场景 参考 线程本地存储模式：没有共享，就没有伤害 ThreadLocal","link":"/2023/11/07/thread-local/"},{"title":"Redis 做缓存可能面临哪些问题？","text":"Redis 做缓存是提升系统性能的利器，但同时也会面临一些问题。本文总结了使用缓存常见的几种问题，以及应对这些问题的方法。 缓存穿透对数据库做缓存时，大部分流量从缓存中返回，少部分未命中缓存的流量才会请求到数据库中，数据库的压力就会比较低。但如果数据在数据库中不存在，自然也不会在缓存中存在，这类流量每次都无法命中缓存，都会请求到数据库中，这样缓存就无法起到降低数据库压力的作用。这种查询不存在数据的现象叫做缓存穿透。 缓存穿透可能是业务逻辑固有的问题，也可能是恶意攻击导致的。针对这两种情况，可以采取的应对措施也不同。 业务逻辑导致的缓存穿透对返回空的 key 值也进行缓存，注意这里是正常返回但是结果为空的情况，发生异常时不能当作空数据进行缓存。 恶意攻击导致的缓存穿透如果是恶意攻击刻意构造不存在的 key 发起请求，缓存空数据的方案就不可行了，这种情况可以借助布隆过滤器来对请求进行一层过滤。 布隆过滤器是用最小代价来判断元素是否存在于某个集合中的方法。虽然维护布隆过滤器需要一定的成本，但是相比攻击导致的资源损耗还是值得的。 缓存击穿如果缓存中的某些热点数据因为某种原因突然失效，比如典型地由于超期而失效，同时又有大量针对该数据的请求发送进来，那么这些请求因为无法命中缓存，都会到达数据库中，导致数据库压力突增，这种现象叫做缓存击穿。 针对缓存击穿，可以采取两种方案： 加锁同步当缓存数据失效时，请求会查询数据库，然后再将查询到的数据写会回缓存。如果将这部逻辑通过互斥锁保护起来，这样最多只有一个请求能够达到数据库中，其它请求可以采取阻塞或者重试的策略。注意 redis 是分布式缓存，这里通常需要采用分布式锁来进行保护。 热点数据手动管理缓存击穿是由于热点数据失效导致的问题，对于这类数据，我们可以通过代码进行有计划的更新，避免自缓存自动失效。 缓存雪崩大批量不同的数据在短时间内一起失效的话，针对这些数据的请求都会击穿缓存，到达数据库，导致数据库压力剧增，这种现象叫过缓存雪崩。 缓存雪崩可能是由于服务有专门的缓存预热功能，或者大量数据都是由某一次冷操作加载的，这样导致由此载入缓存的数据具有相同的过期时间，在同一时刻一起失效；还可能是缓存服务崩溃重启，造成大量数据同时失效。 针对缓存雪崩，我们可以采取以下三种方案： 提升缓存系统的可用性，比如集群部署，支持故障检测、主备切换等； 使用本地缓存，各个服务节点的本地缓存通常具有不同的加载时间，从而过期时间就会比较分散 将缓存的过期时间从固定时间改为一个时间段内的随机事件，比如原来是两个小时过期，现在设置为 110 分钟到 130 分钟之间的某个随机值 缓存污染缓存污染是指缓存和数据库数据不一致的现象。通常使用缓存时，不会追求强一致性，但是最终一致性还是需要保证的。 缓存污染问题通常是由于代码开发不规范导致的，比如更新缓存数据后，由于某些原因，比如业务发生异常回滚，导致数据没有写入数据库中，这时缓存中数据是新的，但是数据库还是就数据。 为了尽可能保证缓存数据的一致性，业内总结了很多更新缓存的设计模式，包括 Cache Aside、Read/Write Through、Write Behind Caching 等等，其中最常用的是 Cache Aside 模式，因为它最简单、成本最低。主要内容可以概括为以下两点： 读数据时，首先读缓存，没有缓存，再度数据源，然后将数据写入缓存，再响应请求 写数据时，先写数据源，然后失效缓存 写数据时，这里要注意两点。 一个是先后顺序一定是先数据源，再缓存。如果先失效缓存，再更新数据源，一定存在一段时间内缓存已经删除完毕，数据源还未更新。此时如果有读请求进来，无法命中缓存，就会到达数据源中。 此时读到的还是旧数据，随后又会写到缓存中。等数据更新完成后，就出现了缓存中是旧数据，数据源是新数据，两者数据不一致的情况。 二是应当失效缓存，而不是更新缓存。因为如果是更新缓存，更新过程中数据源又被其它请求修改，缓存要面临多次赋值的复杂时序问题。如果是失效缓存，则无论这个过程中数据源更新了多少次，都不会产生影响。 当然，有一种情况下 Cache Aside 模式也会导致数据不一致，就是如果某个数据是从未被缓存过的，或是恰好超期失效，或是恰好因为更新被失效，读请求就会达到数据源中。如果对数据源的又一个写操作正好发生在查询请求之后，结果回填到缓存前，也会出现缓存中数据和数据源不一致的情况。 相对而言，这种缓存不一致出现的条件更为苛刻一点。通过设置合理的过期时间，可以控制这种情况下的最长影响时间。 通常情况下，Cache Aside 模式依然是一种低成本更新缓存，且能够获得相对可靠结果的解决方案。 BigKeystring 类型超过 10KB，hash、list、set、zset 元素个数超过 5000，可以认为是 big key，可能导致 Redis 性能下降。 BigKey 的产生可能有下面这些原因： 未正确使用 Redis，如使用 String 类型的 key 存放大体积二进制文件型数据 业务规划不足，没有对 key 中的成员进行合理的拆分，造成个别 key 中的成员数量过多 未定期清理无效数据，造成如 HASH 类型 key 中的成员持续不断地增加 服务发生异常，如使用 LIST 类型 key 的业务消费侧发生代码故障，造成对应key 的成员只增不减 BigKey 可能导致以下问题： 大量占用内存，引发操作阻塞或重要的 key被逐出，甚至引发内存溢出 集群架构下，某个数据分片的内存使用率远超其他数据分片，无法使数据分片的内存资源达到均衡 命令执行效率下降，如 lrange、hgetall 等时间复杂度为 O(n) 的命令 对 BigKey 执行读请求，会使 Redis 实例的带宽被占满，影响服务性能 对 BigKey 执行删除操作，易造成主库较长时间的阻塞，进而可能引发同步中断或主从切换 BigKey 需要更多的网络带宽来传输可能导致网路阻塞，特别是在进行备份、复制或者集群间数据同步时 如何定位 BigKey： 通过 redis-cli 的 bigkeys 参数查找 BigKey 通过 Redis 内置命令 DEBUG OBJECT、MEMORY USAGESTRLEN、LLEN 等对目标 Key 进行分析 使用第三方工具redis-rdb-tools，使用过程中会先使用 bgsave 命令dump一个rdb 镜像，然后对这个镜像进行分析 我们可以参考以下几种方案来解决 BigKey 的问题。 第一，尝试压缩 value。 第二，将 BigKey 拆分成多个小 key。 第三，对 BigKey 进行清理，迁移到其它更适合的存储中。 第四，对集合中的过期数据进行定期清理。 第五，删除 BigKey 时，使用 redis4.0 新特性，非阻塞删除。 HotKeyHotKey 是指 Redis 中访问频率特别高的 key。在秒杀、爆款商品、爆款新闻等场景中经常会出现 HotKey，可能导致以下问题： 占用 Redis server 端大量的 CPU 资源，导致整体性能下降 如果是集群架构，会产生访问倾斜，某个内存分片被大量访问，可能导致该分片出现连接数耗尽、性能下降等问题 增加网络流量，可能导致网路阻塞 出现缓存击穿现象，导致数据库压力突增，影响其它业务 访问量超出 Redis server 上限，导致服务崩溃，进一步导致缓存雪崩 如何定位 HotKey： 通过 redis-cli 的 hotkeys 参数查找 HotKey 在业务层增加相应的代码对 Redis 的访问进行监控分析 通过 MONITOR 命令找出 HotKey 我们可以参考以下几种方案来解决 HotKey 的问题。 第一，可以增加本地缓存，来降低 HotKey 的访问频率。不过这种方案会面临缓存不一致、消耗本地内存的问题。 第二，对 HotKey 进行复制，比如将 HotKey foo 复制出 3 个内容完全一样的 Key 并名为 foo2、foo3、foo4。该方案的缺点在于需要联动修改代码，同时也有数据一致性的问题。 第三，在客户端和 Redis server 间接入 proxy 层，通过 proxy 实现读写分离以及读流量在多个从节点间的负载均衡。在请求量极大的场景下，读写分离架构会产生不可避免的延迟，此时会有读取到脏数据的问题。 第四，同样是接入 proxy 层，但 proxy 在这里承担缓存 HotKey 查询结果的职责。类似方案一，改进的地方是对业务层是透明的。 总结本文总结了 Redis 作为缓存的常见问题及解决方案，不同的业务场景下可能会面临不同的问题，可以采取的方案也不尽相同。可以遵循一个原则进行选择，“能满足需求的前提下，最简单的系统就是最好的系统”。 参考 分布式缓存如何与本地缓存配合，提高系统性能？ 发现并处理Redis的大Key和热Key Understanding and Solving HotKey and BigKey issues in Redis Redis Hotspot Key Discovery and Common Solutions","link":"/2023/11/13/redis-problem/"}],"tags":[{"name":"ThreadLocal","slug":"ThreadLocal","link":"/tags/ThreadLocal/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"缓存一致性","slug":"缓存一致性","link":"/tags/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/"},{"name":"缓存雪崩","slug":"缓存雪崩","link":"/tags/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/"},{"name":"缓存穿透","slug":"缓存穿透","link":"/tags/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/"},{"name":"BigKey","slug":"BigKey","link":"/tags/BigKey/"},{"name":"HotKey","slug":"HotKey","link":"/tags/HotKey/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"并发","slug":"并发","link":"/tags/%E5%B9%B6%E5%8F%91/"}],"categories":[{"name":"java","slug":"java","link":"/categories/java/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"并发","slug":"java/并发","link":"/categories/java/%E5%B9%B6%E5%8F%91/"},{"name":"Redis","slug":"数据库/Redis","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"并发","slug":"Java/并发","link":"/categories/Java/%E5%B9%B6%E5%8F%91/"}],"pages":[]}